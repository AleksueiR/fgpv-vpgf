Let's start by making everything more confusing that it was a moment ago. First, some terminology:

## Terminology
### Legend as Devs see it
__Legend__ is a list of (legend) blocks displayed in the main panel (toc pane - table of contents). When opened, the legend pane is titled "Layers" - due to popular user demand.

![](https://i.imgur.com/akbtOVc.png)

Apart from legend blocks describing layers added to the map, legend can also contain arbitrary plain text (markdown or html markup is coming), titles, images, blocks that look like proper layers but do not control anything on the map, groups that don't belong to Dynamic layers, and visibility sets.

> Devs call it: legend, layer Selector, layer List
>
> Users call it: I'm not sure what _users_ call this.

### Legend as Users see it
__Legend__ is a list of icons/images with corresponding labels representing data displayed by a certain layer.

![](https://i.imgur.com/7shujnr.png)

Symbology stacks/legends can display custom images specified in the config and be added to the legend blocks not connected to actual layers.

> Devs call it: symbology stack
>
> User call it: legend

## Legend Types

We are going to explore the legend (dev definitions from here on) as devs see it.

The legend comes in two flavours - ~~vanilla and chocolate~~ structured and autogenerated.

__Structured__ legend lets the config author mess with the ordering of legend blocks, their names, specify custom symbology stacks, put things into regular groups or visibility sets, hide layers from the legend, and have a single legend block controlling several layers. Lots of power options, plenty of opportunities to screw up the config. All this should be used for thematic maps (i.e. maps that tell a certain story with the data).

__Autogenerated__ legend is simple - it takes the layer list and turns it into a legend, one to one correspondence (one regular legend block per one layer).

It should be pointed out the __autogenerated__ legend - after it was generated during the config parse - is technically a __structured__ legend. It uses a subset of elements which can be used in the __structured__ legend.

The only notable difference between the two is ability to reorder and layers in the __autogenerated__ legend. __Structured__ legends are immutable (apart from removing user-added layers - this is allowed by both legend types and cannot be disabled, yet).

### ~~Vanilla~~ Autogenerated Legend

An `entry` (see schema `entry`) is created for each layer object from the config `layers`. This `entry` is defaulted to have the _icons_ style for the symbology stack in Feature and _images_ in WMS layers. Later, `entries` are converted into corresponding legend blocks. Here's an example:
```json
"layers": [
    {
        "id": "powerplant100mw-electric",
        "name": "Electric Transmission Line",
        "layerType": "esriFeature",
        "url": "http://geoappext.nrcan.gc.ca/arcgis/rest/services/NACEI/energy_infrastructure_of_north_america_en/MapServer/1"
    },
    {
        "id": "powerplant100mw-naturalGas",
        "name": "Natural Gas Pipeline",
        "layerType": "esriFeature",
        "url": "http://geoappext.nrcan.gc.ca/arcgis/rest/services/NACEI/energy_infrastructure_of_north_america_en/MapServer/2"
    },
    {
        "id": "powerplant100mw-liquids",
        "name": "Liquids Pipeline",
        "layerType": "esriFeature",
        "url": "http://geoappext.nrcan.gc.ca/arcgis/rest/services/NACEI/energy_infrastructure_of_north_america_en/MapServer/3"
    }
]
```

This simple, three-layer layer list will yield a three-entry legend (quite boring actually):
```json
"legend": [
    {
        "layerId": "powerplant100mw-electric"
    },
    {
        "layerId": "powerplant100mw-naturalGas"
    },
    {
        "layerId": "powerplant100mw-liquids"
    }
]
```

That's it. The legend will display these three layers in the order they are specified in the `layers` section of the config. All controls will be available by default (except instances where they are disabled due to the nature of the underlying layer - think of not-true-dynamic Dynamic layers and their children opacity). Images for symbology stacks will be pulled from layer renderer definitions.

### ~~Chocolate~~ Structured Legend

__Structured__ legend is a funny beast, let's go over what can be included in it first:

#### Info Section

__Info section__ is a piece of static content (unless it's a .gif) which can be added between any other legend blocks. There are four types: text, title, image, and unbound layer.

##### Text

Just plain text, no formatting will be processed.

```json
{
    "infoType": "text",
    "content": "They say it's as big as four cats and has a retractable leg so it can leap up at you better and it lights up at night and it's got four ears, two are for listening and the other two are kind of back up ears and it's claws are as big as cups and for some reason it's got a tremendous fear of stamps, Mrs Doyle was telling me it's got magnets on it's tail, so if you're made of metal, it can attach itself to you and instead of a head, it's got four arses."
}
```

![](https://i.imgur.com/MM2475D.png)

##### Title

Almost the same as text, but with a larger font size.

```json
{
    "infoType": "title",
    "content": "Confusing Opacity Controls"
}
```

![](https://i.imgur.com/pIehaRA.png)

##### Image

Adds an image to the legend; all common formats are supported.

```json
{
    "infoType": "image",
    "content": "http://fgpv.cloudapp.net/demo/__assets__/solazy.gif"
}
```

![](https://i.imgur.com/z3PopmH.png)


##### Unbound Layer

An __unbound layer__ info section copies some of its looks from the regular legend block: it has a name and a symbology stack.

```json
{
    "infoType": "unboundLayer",
    "layerName": "How to catch Santa (//www.pusheen.com/)",
    "symbologyStack": [
        {
            "image": "http://fgpv.cloudapp.net/demo/__assets__/step1.gif",
            "text":"1. Set your bait"
        },
        {
            "image": "http://fgpv.cloudapp.net/demo/__assets__/step2.gif",
            "text":"2. Hide"
        },
        {
            "image": "http://fgpv.cloudapp.net/demo/__assets__/step3.gif",
            "text":"3. Don't eat the bait"
        },
        {
            "image": "http://fgpv.cloudapp.net/demo/__assets__/step4.gif",
            "text":"4. Don't do it"
        },
        {
            "image": "http://fgpv.cloudapp.net/demo/__assets__/step5.gif",
            "text":"5. Stop!!"
        },
        {
            "image": "http://fgpv.cloudapp.net/demo/__assets__/step6.gif",
            "text":"6. You ruined it!"
        }
    ],
    "symbologyRenderStyle": "images"
}
```

![](https://i.imgur.com/yiPlbtJ.png)

#### Entry (config) or Legend Node (code)

This is the workhorse of the structured legend. Let's look at the simplest one:

```json
{
    "layerId": "powerplant100mw-electric"
}
```

And this looks exactly as the one produced by the autogenerated legend - all the default values apply. There are many options you can specify and change for the legend block. Here's its schema definition:

```json
"entry": {
    "type": "object",
    "description": "",
    "properties": {
        "layerId": {"type": "string", "description": "Link to a layer defined in the layers section"},
        "hidden": {"type": "boolean", "default": false, "description": "Indicates that the legend block will be hidden from the UI and all its controls will be inaccessible to the user." },
        "controlledIds": {
            "type": "array",
            "items": { "type": "string", "description": "Additional layer ids which are controlled by this layer" },
            "default": []
        },
        "entryIndex": {"type": "integer", "description": "Index of the 'sublayer' in the case of an ESRI dynamic layer.  This cannot point to an entry with stateOnly:true ."},
        "entryId": {"type": "string", "description": "Id of the 'sublayer' in the case of an OGC WMS layer"},
        "coverIcon": {"type": "string", "description": "An optional icon, if present it will be used to primarily represent the layer"},
        "symbologyStack": { "$ref": "#/definitions/symbologyStack" },
        "symbologyRenderStyle": {"type":"string", "enum": [ "icons", "images" ], "description": "An optional style, describes how the symbology stack should be rendered"}
    },
    "required": ["layerId"],
    "additionalProperties": false
}
```

> Note: `coverIcon` and `entryId` options are not yet implemented.

`entryIndex` option allows a direct link to a child of a Dynamic layer.

A dynamic layer with five layer entries specified.
```json
{
    "id":"ecogeo",
    "name": "Eco Geo",
    "layerType":"esriDynamic",
    "url":"http://section917.cloudapp.net/arcgis/rest/services/EcoGeo/MapServer/",
    "layerEntries": [ { "index": 0 }, { "index": 1 }, { "index": 2 }, { "index": 3 }, { "index": 4 }]
}
```

Adding this to the legend as `{ "layerId": "ecogeo" }` would create an "Eco Geo" group with five children under it. To add just two children - entries 2 and 4 - create two legend blocks that reference these child entries directly:

```json
{
    "layerId": "ecogeo",
    "entryIndex": 2
},
{
    "layerId": "ecogeo",
    "entryIndex": 4
}
```

![](https://i.imgur.com/0GAhZFm.png)

`controlledIds` option lets a single legend block to control properties of several layers. This is useful if you want to bundle some datasets.

```json
{
    "layerId": "allYourBaseBelongToUs",
    "controlledIds": [
        "base1",
        "base2",
        "base3"
    ]
}
```

`symbologyStack` overrides the default symbology retrieved from the services and displays custom images provided.

`symbologyRenderStyle` changes how the symbology stack is rendered. `icons` (the default) are well suited for Features services where separate symbols exist - symbols will always be sized down to 32x32 px container and their labels will be displayed to the right of the symbol (symbols will not be sized up if smaller). `images` can be used when symbols are all different sizes and/or contain text - they will be sized down to the width of the panel and their labels are displayed underneath the images.

Here's how custom symbology stacks added to the above example render:

```json
{
    "layerId": "ecogeo",
    "entryIndex": 2,
    "symbologyStack": [{
        "image": "https://i.imgur.com/hde8BLK.png",
        "text": "Canada Outline"
    }],
    "symbologyRenderStyle": "icons"
},
{
    "layerId": "ecogeo",
    "entryIndex": 2,
    "symbologyStack": [{
        "image": "https://i.imgur.com/hde8BLK.png",
        "text": "Canada Outline"
    }],
    "symbologyRenderStyle": "images"
}
```

![](https://i.imgur.com/uj7JAYW.png)

> Note: the `description` option will available in 2.1 version of the schema and it adds an optional, plain text description to the top of the symbology stack.

#### Entry Group (config) or Legend Group (code)

These let you group things into collapsible sections. Anything can be put inside a group, including other groups (group nesting). Nesting them more than ten levels deep will not produce any changes in the UI - it's a flat list from there on.

Groups are rather simple - they have names, children, controls that should be available to the user and controls that should be disabled. See more information about controls at the bottom of this guide.

```json
{
    "name": "I'm Group",
    "children": [
        {
            "layerId": "powerplant100mw-electric"
        },
        {
            "layerId": "powerplant100mw-naturalGas"
        },
        {
            "layerId": "powerplant100mw-liquids"
        }
    ],
    "controls": ["visibility", "opacity"],
    "disabledControls": ["visibility"],
    "expanded": true
}
```

A group can be initially expanded or collapsed which help with setting up the stage for the first load - expanding groups with important for user information, and collapsing all auxiliary groups.

![](https://i.imgur.com/XbWnBhV.png)


#### Visibility Set

This is a convenience for the user when at most a single element from a set can be visible at a time - it's possible to have all elements in the set turned off. They groups things together, but there is no header element. It's also not possible to nest visibility sets directly - it just doesn't make sense. You can put a set into a group and put that group into another set, if that's your fancy. Trying to make nested sets will only confuse the users and devs.

Here's a simple example of a set:

```json
{
    "exclusiveVisibility": [
        {
            "layerId": "powerplant100mw-electric"
        },
        {
            "layerId": "powerplant100mw-naturalGas"
        },
        {
            "layerId": "powerplant100mw-liquids"
        }
    ]
}
```

The visibility set is rendered a bit differently from a group - it uses radio buttons instead of checkboxes in visibility controls. This helps to convey the "one of" nature of a visibility set. There is also some nice highlighting to clearly mark which legend blocks belong to which set if there are two sets placed one after another for example.

![](https://i.imgur.com/03LBcC4.png)

### Other Notes

#### Changing Names

To change a name of a `group`, you can modify its _legend_ definition:

```json
{
    "name": "custom group name",
    "children": [
        ...
    ]
}
]
```

To change a name of a `node`, you need to modify the its _layer_ definition, so it's a bit more involved. Groups are artificial constructs and don't have natural names, while layers do.

```json
"legend": {
    "type": "structured",
    "root": {
       "name": "root",
        "children": [
            {
                "layerId": "powerplant100mw-electric"
            }
        ]
    }
}
```

```json
"layers": [
    {
        "id": "powerplant100mw-electric",
        "name": "Some Custom Name",
        "layerType": "esriFeature",
        "url": "www..."
    }
]
```

#### With a lot of power

There are probably many ways to screw up config and either get undefined behaviour or runtime errors with a valid config. One way would be to cross-control layers. Observe:

```json
{
    "layerId": "base1",
    "controlledIds": [
        "base2"
    ]
},
{
    "layerId": "base2",
    "controlledIds": [
        "base1"
    ]
}
```

We don't know what will happen, maybe a black hole will form. Don't do this.

As a rule of thumb, if it doesn't make logical sense, it probably won't work even if the config validates.

#### About controls
Each layer and group has two arrays of control settings: `controls` and `disabledControls`.
`controls` specify if the layer has corresponding ui elements to control the setting
`disabledControls` specify if the corresponding setting can be modified

| control | disabledControl | result                                                          |
|---------|-----------------|-----------------------------------------------------------------|
| x       |                 | control is visible to the user and can be modified                             |
|         | x               | control is invisible and is locked to modification                             |
|         |                 | control is invisible to the user, but can be modified indirectly, by a parent   |
| x       | x               | control is visible and is locked to modifications                              |

## Legend Generation (LegendService)

The LegendService is responsible for converting the entries, entryGroups, and other items from the legend section of the config into appropriate LegendBlocks which will then be rendered in UI. The concept is simple - take an legend entry from the config, create a LegendBlock, and link it to the corresponding LayerRecord, and yet the `legend.service.js` file is currently 800 lines long.

### constructLegend

This function is invoked only once per every config load and will generate initial legend based on the config data. All additional layers need to be added to the legend separately, one by one. `constructLegend` function takes in an array of legend blocks and an array of layer definitions. Each layer definition is converted into a layer blueprint for future references by the legend blocks. It's possible for a single layer record to be referenced in several layer blocks, and for some layer records not to be used at all. Layer blueprints are just that, dormant layer record templates which are only instantiated when a corresponding reference is found in a legend block.

Next, the legend tree is processed. Group, Info, and Set legend blocks are very straightforward to create - they are static and not directly connected to the layer record. Groups and Sets are containers for other blocks, while Info blocks are just hold some text or image data.

An additional mapping is created which holds an array of references to the legendBlock and the corresponding blockConfig objects that belong to a particular layerRecord in the form of `{ <layerRecordId>: [ { legendBlockId: <String>, blockConfigId: <String> }, ... ] }`.

This is used when reloading or removing legend blocks. Since the user can issue to reload or remove a single legend block, and several legend blocks can potentially reference a single layer, all legend blocks connected to that layer need to be re-created. This mapping makes it easier to track such cases.

When creating a Legend Node block (`_makeLegendBlock`), first the appropriate blueprints are found - there must be a single main blueprint and zero or more controlled blueprints (`controlledIds` option from the config). Then, legend block is mapped to the entry type:
- all single entries except for entries whose main blueprint is of `esriDynamic` type are rendered as `LegendNode`s
- all single entries whose main blueprint is of `esriDynamic` type are rendered as `LegendGroup`s
- all child entries of a entry referencing an `EsriDynamic` layer, are rendered according to that layer's structure, after the layer has been loaded - this cannot be determined upfront
- `ogcWMS` are rendered as `LegendNode`s for now

#### _makeNodeBlock

First, a referenced layer record for this block is retrieved from the `layerRegistry` - the record might already exist or not (if not, it's created and loaded), and its proxy object extracted. This happens in `_getLegendBlockProxy`.

This proxy object is then wrapped in a `ProxyWrapper` together with the corresponding layer config snippet. This is required since layer config might have settings specified that are not available through the layer proxy. Also, initial opacity, visibility, and query states are set on the proxy objects here using the values from the layer config. As the properties being changed by the user, the layer config is being updated along with the proxy object. This is useful when the layer needs to be reloaded - it automatically keeps all the latest settings are they are ultimately stored in the layer blueprint.

Next, the actual `LegendNode` object is created and an appropriate `legendMappings` is made. A on-load listener is set on the corresponding layer record which will apply initial settings specified in the config to the layer proxy object (`LegendNode.applyInitialStateSettings`). This is needed to apply state settings that are not set in geoApi (dynamic layers, for example, start up as fully invisible to prevent flicker on initial load).

The controlled blueprints are processed next. A flat list of controlled blueprints is converted into a flat list of `ProxyWrapper`s using `_getControlledLegendBlockProxy`. Each controlled proxy wrapper is added to the `LegendBlock` and its settings are synchronized with the main layer record (`LegendNode.addControlledProxyWrapper` and `LegendNode.synchronizeControlledProxyWrappers`). Only `opacity` and `visibility` properties are synchronized between the main and controlled blueprints. It's one way synchronization - changes made on the legend block (and its main layer record) are forced on controlled layer records.

It's possible to prevent this by disabling `visibility` or `opacity` controls on the controlled layer records:

```json
"legend": {
    "type": "structured",
    "root": {
       "name": "root",
        "children": [
            {
                "layerId": "powerplant100mw-electric",
                "controlledIds": [
                    "powerplant100mw-naturalGas"
                ]
            }
        ]
    }
}
```

```json
"layers": [
    {
        "id": "powerplant100mw-electric",
        "name": "Some Custom Name",
        "layerType": "esriFeature",
        "url": "www..."
    },
    {
        "id": "powerplant100mw-naturalGas",
        "name": "Natural Gas Pipeline",
        "layerType": "esriFeature",
        "disabledControls": ["opacity", "visibility"],
        "url": "www..."
    }
]
```

In this case, the controlled `powerplant100mw-naturalGas` layer will always be visible on the map, even if its master `powerplant100mw-electric` is turned off.

#### _makeDynamicGroupBlock

This is most convoluted one. Dynamic entries are rendered as a group (unless they are single entry collapsed), with children, some of which can also be groups, depending on the layer structure, which is unknown until the layer is loaded.

First, we get the `ProxyWrapper` for the Dynamic layer itself and construct a new `LegendGroup` config for it. A new group config is needed since an `entry` is turned into a `group` and groups have some different controls and settings. With the new config and the `ProxyWrapper` the `LegendGroup` block is created and mapped to its layer. Then a on-load listener is set which will run `_createDynamicChildTree` to create a tree since now we know the layer structure. The tree is parsed and all its children are added to the `LegendGroup` block created in the beginning (`_addChildBlock`). The settings of leaves are synchronized (`LegendNode.applyInitialStateSettings`).

The controlled layers are processed in a similar fassion to controlled layers on a `LegendNode` with huge difference - controlled `ProxyWrapper`s are actually turned into normal legend blocks which are added to the group as usual. These blocks are marked as `controlled` which precludes them from being rendered.

#### _getControlledLegendBlockProxy

This function is used by all layer types to create a flat list of controlled `ProxyWrapper`s. First, controlled wrappers get their `boundingBox` and `query` settings and states disabled. If the controlled layer is not a Dynamic one, layer record is retrieved, its proxy object is obtained, wrapped and returned. Easy.

If the controlled layer is a Dynamic layer, we first need to wait for it to load since its structure is unknown, then its child tree created (`_createDynamicChildTree`), and their `ProxyWrapper`s extracted as a flat list (their hierarchy is irrelevant since they will never be rendered in UI, so we are content with a flat list).

#### _createDynamicChildTree

This function parses the child tree returned by the service, and creates a config for each child using options specified in the config (if any), child defaults, group defaults, and their parent defaults (see `ConfigObject.applyLayerNodeDefaults` for details on how defaults are applied in this case).

Let's say we have this legend and layer definitions from the config file:

```json
"legend": {
    "type": "structured",
    "root": {
       "name": "root",
        "children": [
            {
                "layerId": "one",
            }
        ]
    }
}
```

```json
"layers": [
    {
        "id": "one",
        "name": "Dynamic Layer",
        "layerType": "esriDynamic",
        "url": "www...",
        "layerEntries": [{"index": 1}]
    }
]
```

The service returns the following child tree:

```json
[
    {
        "entryIndex":1,
        "name":"Group2",
        "childs":[
            { "entryIndex":2 }
        ]
    }
]
```

And we end up with the following legend blocks:

```json
LegendGroup: "Dynamic Layer"
    LegendGroup: "Group2"
        LegendNode: "prox_point_l2"
```

When all of these additional block configs are created, they are stored in the original layer config source and the layer itself is considered `resolved`. The next time this layer is reloaded or restored from a bookmark, its config is complete and there is no need to apply defaults (if defaults are applied, they will mess up stored state).

### importLayerBlueprint

Adding a new layer blueprint is simple - generate an entry config (importing a layer blueprint works as autogenerated legend), make a legend block and add it to the existing legend blocks. For the last step, you need to find an appropriate place to insert the newcomer: in `autogenerate` legend, the new layer is added at the top of its respective group (Feature layers or everything else); in `structured` legend, the new layer is added to the position provided to `importLayerBlueprint` or at the bottom of the legend.

It's added to `legendMappings` and the new block config is added to the legend config (always to the root group), so it will be preserved when map is rebuilt.

### reloadBoundLegendBlocks

A trick in reloading a legend block is to find all the legend blocks connected to the underlying layer record and update all of them. Getting a layerRecordId, regenerate the layer record (`layerRegistry.regenerateLayerRecord`), go through `legendMappings` and find all the legend blocks involved. Reload all the layers which are controlled by these legend block in a recursive call to `reloadBoundLegendBlocks`. After this is done, create a new `LegendNode` and replace the old one. Don't forget to remove any leftover bounding boxes, as they are separate entities from the legend blocks.


### removeLegendBlock

Removing a legend block involves pulling out the block from the legend, and turning off visibility on the corresponding layer record. `removeLegendBlock` returns two functions - to remove completely and restore the legend block. The caller function must decide what to do.

Removing completely means calling `layerRegistry.removeLayerRecord` to kill the layer record and remove the leftover bounding boxes (the actual legend block is already removed from the legend).

Restoring adds the legend block back to its place and restored cached visibility values (in cases of dynamic layers, there can be more than one).

> Note: since removing legend blocks is only allowed for user-added layers and autogenerated legends, it's safe to assume there is only one legend block per layer record.


## Notes

Config samples used __2.1__ version of the schema.